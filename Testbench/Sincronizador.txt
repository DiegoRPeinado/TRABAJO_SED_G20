library IEEE;
use IEEE.Std_logic_1164.all;
use IEEE.Numeric_Std.all;

entity SYNCHRNZR_tb is
end;

architecture bench of SYNCHRNZR_tb is

  component SYNCHRNZR
      Port ( CLK : in STD_LOGIC;
             ASYNC_IN: in STD_LOGIC_VECTOR (5 downto 0);
             SYNCD_MONEDAS: out STD_LOGIC_VECTOR (3 downto 0);
             SYNCD_PAGAR: out STD_LOGIC;
             SYNCD_TIPO_REFRESCO: out STD_LOGIC);
  end component;

  signal CLK: STD_LOGIC;
  signal ASYNC_IN: STD_LOGIC_VECTOR (5 downto 0);
  signal SYNCD_MONEDAS: STD_LOGIC_VECTOR (3 downto 0);
  signal SYNCD_PAGAR: STD_LOGIC;
  signal SYNCD_TIPO_REFRESCO: STD_LOGIC;

  constant clock_period: time := 10 ns;


begin

  uut: SYNCHRNZR port map ( CLK                 => CLK,
                            ASYNC_IN            => ASYNC_IN,
                            SYNCD_MONEDAS       => SYNCD_MONEDAS,
                            SYNCD_PAGAR         => SYNCD_PAGAR,
                            SYNCD_TIPO_REFRESCO => SYNCD_TIPO_REFRESCO );
                            
  
 CLK_TREATMENT: process
 begin
 
 clk <= '0';
 wait for 0.5 * clock_period;
 
 clk <= '1';
 wait for 0.5 * clock_period;
 
 end process;

  stimulus: process
  begin
  
	ASYNC_IN <= "000000";
    wait for clock_period;
    
    ASYNC_IN <= "010100";
    wait for clock_period * 2; 
    
    assert SYNCD_MONEDAS = "0100"
    	report "SYNCD_PAGAR should be 0100.";
    assert SYNCD_PAGAR = '1'
    	report "SYNCD_PAGAR should be '1'.";
    assert SYNCD_TIPO_REFRESCO = '0'
    	report "SYNCD_PAGAR should be '0'.";
    
   ASYNC_IN <= "100001";
   wait for clock_period * 2;
   
   assert SYNCD_MONEDAS = "0001"
    	report "SYNCD_PAGAR should be 0001.";
    assert SYNCD_PAGAR = '0'
    	report "SYNCD_PAGAR should be '0'.";
    assert SYNCD_TIPO_REFRESCO = '1'
    	report "SYNCD_PAGAR should be '1'.";
    
    wait for clock_period;
    
	assert false
    report "Success: simulation finished."
    severity failure;


    wait;
  end process;

end;